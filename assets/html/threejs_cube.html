<!--- RTView HTML Snippet: ThreeJS Cube Example -->
<!-- 
TODO: 
*** Wait for initial load to complete, to avoid failure on first render
*** Implement resize so drawing area tracks resize
*** Reload causes warning: three.min.js:188 WARNING: Too many active WebGL contexts. Oldest context will be lost.
*** After selection, context is lost, seems to create whole new object which then does not render
*** Find way to add transparency, alpha not working
-->
<script src="http://threejs.org/build/three.min.js"></script>

<canvas id="theCanvas" data-type="threejs-cube" data-height="480" data-width="480"></canvas>

<script>

(function() {
	var gauge = document.getElementById('theCanvas')
    console.log('... found gauge: ' + gauge.id);
	gauge.id = rtv.ui.getUniqueId();
    console.log('... new id: ' + gauge.id);
	gauge.rtvPanel = rtvPanel;
	gauge.rtvDiagramContext = rtvPanel.parentPanel;
	rtvPanel.gauge = gauge;

	var gaugeConfig = {
        bgColor: '#eeeeee',
       
		value: 65
	};
	gauge.config = gaugeConfig;
    
    console.log('... about to do threejs stuff');
    
    // set initial width; but sometimes it starts out as 0
    var width = rtvPanel.container.offsetWidth - 2;
    if (width < 0) width = 0;
    var height = rtvPanel.container.offsetHeight - 2;
    if (height < 0) height = 0;
    console.log('initial panel size = ' + width + ' x ' + height);
    
    var scene = new THREE.Scene();
    scene.background = new THREE.Color( gauge.config.bgColor );
       
    var camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );
    camera.position.x = 0;
    camera.position.z = 5;
    
        //LIGHTS
    var light = new THREE.AmbientLight(0x0ffffff, 0.8);
    scene.add(light);

    var light2 = new THREE.PointLight(0xffffff, 0.8);
    light2.position.x = 0;
    light2.position.y = 8;
    light2.position.z = 4;
    scene.add(light2);
    
    var container = document.getElementById('theCanvas')
    container = gauge;
    //renderer = new THREE.WebGLRenderer( { canvas: gauge, alpha: true } );
    renderer = new THREE.WebGLRenderer( { canvas: gauge } );
    
    // neither of these seems to work to provide tranparency
    //renderer.setClearColor( '#eeddcc', 0.5 );
    //renderer.setClearAlpha( 0.5 );
    //renderer.shadowMap.enabled = true;
    //renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    renderer.setSize( width, height );
    
    //container.appendChild( renderer.domElement );
    
    var geometry = new THREE.BoxGeometry( 2, 2, 2 );
    //var material = new THREE.MeshBasicMaterial( { color: 0x35638b } );
    var material = new THREE.MeshLambertMaterial( { color: 0x00d8dd } )
    var cube = new THREE.Mesh( geometry, material );
    scene.add( cube );
    
    console.log('... rendering');
    
    var animate = function () {
        requestAnimationFrame( animate );

        cube.rotation.x += 0.01;
        cube.rotation.y += 0.02;
        cube.rotation.z += 0.03;

        //console.log('... rendering 2');
        renderer.render( scene, camera );
        
    };

    animate();
            

	function applyVarToGauge (gauge, name, value) {
        function toDash(strCamel){
	        return strCamel.replace(/([A-Z])/g, function($1){return "-"+$1.toLowerCase();});
        };
        if (name == 'bgColor') {
            scene.background = new THREE.Color( value );
            renderer.render( scene, camera );
            
		}else if (name == "dataHighlights" && typeof value != "string") 
			try {value = JSON.stringify(value);} catch(e) {console.error(e);}
		else if (value && value.isDataTable)
			value = rtv.dac.tableToScalar(value);
		gauge.setAttribute(toDash(name), value);
        //console.log("rgauge: "+toDash(name)+"="+value);
	}

	function applyVarsToGauge(rtvPanel) {
		if(rtvPanel.gauge !== undefined) {
			Object.keys(rtvPanel.gauge.config).forEach(function(key){
				applyVarToGauge(rtvPanel.gauge, key, rtvPanel.getVarValue(key));
			});
            //console.log("vars applied to r-gauge");
		} else {
			console.log("apply vars - myGauge not defined");
		}
	}


	rtvPanel.setDisplayProperties({
		localVars: gaugeConfig
	});
    applyVarsToGauge(rtvPanel);  // apply initial var values
    setTimeout(function(){applyVarsToGauge(rtvPanel)}, 10);
	
	// add listener for each var, to apply updates
	Object.keys(gaugeConfig).forEach(function(varName) {
        let rtvp = rtvPanel;
		rtvp.addVarListener(varName, 
			function(value){applyVarToGauge(rtvp.gauge, varName, value)}, true);
	});
    
	var resizeTimerID;
	
	function resizeGaugeToFit () {
		resizeTimerID = undefined;
		var width = rtvPanel.container.offsetWidth - 2;
		var height = rtvPanel.container.offsetHeight - 2;
		console.log('  ... set panel size = ' + width + ' x ' + height);
        
		if (width > 0 && height > 0) {
			rtvPanel.gauge.setAttribute('data-width', width);
			rtvPanel.gauge.setAttribute('data-height', height);
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize( width, height );
		}	
	}
	
	rtvPanel.resizedCB = function(dim) {
        console.log('... in resizeCB');
		if (!dim) {
			// initial size, do it immed
            console.log('  ... in initial rezieCB');
			resizeGaugeToFit();
		} else {
			// an interactive resize event, do it later in case more are coming
			if (resizeTimerID) {
				clearTimeout(resizeTimerID);
			}
			resizeTimerID = setTimeout(resizeGaugeToFit, 10);
		}
	};
        
})();
 
</script>
