<!--- RTView HTML Snippet: ThreeJS Cube Example -->

<div data-rtvid="theCanvas">
<canvas id="theRealCanvas" data-type="threejs-cube2" data-height="480" data-width="480"></canvas>
</div>

<script>

// js vars used by functions within this scope
var gyroCanvas, scene, camera, renderer, animator;
var wrapper, box;
var ground, grid, controls; 

var threeJsObjects = [];

// Instance variables exposed to user
var gyroConfig = {
	bgColor: '#eeeeee',   
	yaw: 1,
	pitch: 0,
	roll: 0,   
    showGround: true,
    enableControl: false
};
const verbose = false;

// log
function trace (msg) {
	if (verbose) {
		console.log(msg);
	}
}

// keep list of 3js objects, for cleanup
function add3js (obj) {
	threeJsObjects.push(obj);
	return obj;
}

function getDimsForCanvas () {
	return {
		width: Math.max(rtvPanel.container.offsetWidth - 2, 1),
		height: Math.max(rtvPanel.container.offsetHeight - 2, 1)
	}
}

// make the 3js gyro object 
function makeGyro () {

    gyroCanvas = rtvPanel.getElementByRtvId('theCanvas');
	
	scene = add3js(new THREE.Scene());
	scene.background = add3js(new THREE.Color( gyroConfig.bgColor ));
	
	var dims = getDimsForCanvas();
	camera = add3js(new THREE.PerspectiveCamera( 75, dims.width / dims.height, 0.1, 1000 ));
	camera.position.x = -4;
	camera.position.y = 4;
	camera.position.z = 2;
	
	camera.lookAt( add3js(new THREE.Vector3(0, 0, 0) ));
	
		//LIGHTS
	var light = add3js(new THREE.AmbientLight(0x0ffffff, 0.8));
	scene.add(light);

	var light2 = add3js(new THREE.DirectionalLight(0xffffff, 0.8));
	light2.position.set(-6, 16, 12);
    light2.castShadow = true;
    light2.shadow.camera.top = 18;
    light2.shadow.camera.bottom = - 10;
    light2.shadow.camera.left = - 12;
    light2.shadow.camera.right = 12;
    
    // increase size of shadow map for better shadows
    light2.angle = Math.PI / 8.0;
    light2.shadow.mapSize.width = 2048;
    light2.shadow.mapSize.height = 2048;
  
	scene.add(light2);
	
    // create renderer with correct dimensions and attach to canvas
    renderer = add3js(new THREE.WebGLRenderer( { canvas: gyroCanvas.children[0] } ));
	renderer.setSize( dims.width, dims.height ); 
    renderer.shadowMap.enabled = true;    
    gyroCanvas.appendChild( renderer.domElement );
    
    // install Orbit Controls if enabled
    enableOrbitControls(gyroConfig.enableControl);

    // ground plane for shadow if visible
    setGroundPlaneVis(gyroConfig.showGround);
	
	wrapper = add3js(new THREE.Object3D());
	wrapper.rotation.x = -(Math.PI / 2);
	scene.add( wrapper );
	
	// Create a set of axes so we can get oriented
	var axesHelper = add3js(new THREE.AxesHelper( 5 ));
	wrapper.add( axesHelper );
	   
	// Create the gyro 'box'
    makeGyroBox(wrapper);
	
	renderer.render( scene, camera );
}

// set visibility of ground plane for shadow 
// create ground plane first time this is called
function setGroundPlaneVis (vis) {
    if (!ground && vis) {
        ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 1000, 1000 ),
                    new THREE.MeshPhongMaterial( { color: 0xb0baa5, depthWrite: false } ) );
        ground.rotation.x = - Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        ground.visible = gyroConfig.showGround;
        scene.add( ground );

        grid = new THREE.GridHelper( 1000, 40, 0x000000, 0x000000 );
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        grid.position.y = -3;
        scene.add( grid );
    }
    if (ground) {
        ground.visible = vis;
        grid.visible = vis;
    }
}

// Install OrbitControls if enabled
function enableOrbitControls (enabled) {   
    if (!controls && enabled) {
        controls = add3js(new THREE.OrbitControls( camera, renderer.domElement ));
		controls.addEventListener( 'change', redrawGyro);
    }
    if (controls) {
        controls.enabled = enabled;
    }
}

// Create simple gyro box
function makeGyroBox (wrapper) {
    if (!box) {
        var geometry = add3js(new THREE.BoxGeometry( 2, 4, 1 ));
        var material = add3js(new THREE.MeshLambertMaterial( { color: 0x00d8dd } ));
        box = add3js(new THREE.Mesh( geometry, material ));
        box.castShadow = true;
        wrapper.add( box );
    }
    if (box) {
        box.visible = true;
    }
}

// *********************************************************************************
// UTILITY FUNCTIONS
   
function cleanupGyro () {
	cancelAnimationFrame(animator);
	threeJsObjects.forEach(function(obj) {
		if (obj.dispose) {
			obj.dispose();
		}
	});
	threeJsObjects = [];
}

function redrawGyro () {
	renderer.render( scene, camera );
}

function updateGyroPos () {
	animator = undefined;
	
    if (!box) return;
    
    box.rotation.x += Math.PI * gyroConfig.pitch / 180;
    box.rotation.y += Math.PI * gyroConfig.roll / 180;
    box.rotation.z += Math.PI * gyroConfig.yaw / 180;
	
	// if anything changed, render object
    redrawGyro();

    // schedule next transition
    animator = requestAnimationFrame(updateGyroPos);

};

function convertToBoolean (value) {
	if (typeof value === 'boolean') return value;
	return value && value !== 'false' ? true : false;
}

var updatePending;

// Apply single variable to the object
function applyVarToGyro (name, value) {
	trace('... set prop ' + name + ' to ' + JSON.stringify(value));
	if (value && value.isDataTable) value = rtv.dac.tableToScalar(value);
	var redraw, updatePos;
	switch (name) {
		case 'bgColor':
			scene.background = add3js(new THREE.Color( value ));
			redraw = true;
			break;

        case 'showGround':
            gyroConfig.showGround = value = convertToBoolean(value);
            setGroundPlaneVis(value);
			redraw = true;
			break;
        case 'enableControl':
            gyroConfig.enableControl = value = convertToBoolean(value);
            enableOrbitControls(value);
			break;
            
		case 'yaw':
            gyroConfig.yaw = value;
			updatePos = true;
			break;
		case 'pitch':
            gyroConfig.pitch = value;
			updatePos = true;
			break;
		case 'roll':
            gyroConfig.roll = value;
			updatePos = true;
			break;
            
		default:
			break;
	}
	
	// schedule update
	if (updatePos && !updatePending && !animator) {
        updatePending = true;
		setTimeout(function() {
			updateGyroPos();
			updatePending = false;
		}, 100);
	}
	if (redraw) {
		redrawGyro();
	}
}

// Apply all the variables to the object
function applyVarsToGyro(rtvPanel) {
	if (gyroCanvas !== undefined) {
		Object.keys(gyroConfig).forEach(function(key){
			applyVarToGyro(key, rtvPanel.getVarValue(key));
		});
		//console.log("vars applied to r-gyro");
	} else {
		console.log("apply vars - myGyro not defined");
	}
}

// Resize the object to fit panel
function resizeGyroToFit () {
	resizeTimerID = undefined;
	var dims = getDimsForCanvas();
	var width = dims.width
	var height = dims.height;
	
	if (gyroCanvas && width > 0 && height > 0) {
		gyroCanvas.setAttribute('data-width', width);
		gyroCanvas.setAttribute('data-height', height);
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
		renderer.setSize( width, height );
	}	
}

// interactive resize callback
var resizeTimerID;
rtvPanel.resizedCB = function(dim) {
	if (!dim) {
		// initial size, do it immed
		resizeGyroToFit();
	} else {
		// an interactive resize event, do it later in case more are coming
		if (resizeTimerID) {
			clearTimeout(resizeTimerID);
		}
		resizeTimerID = setTimeout(resizeGyroToFit, 10);
	}
};

function addVarListeners () {
	// add listener for each var, to apply updates
	Object.keys(gyroConfig).forEach(function(varName) {
		let rtvp = rtvPanel;
		rtvp.addVarListener(varName, 
			function(value){applyVarToGyro(varName, value)}, true);
	});
}

// Instance the object in RTView
rtvPanel.setDisplayProperties({
	localVars: gyroConfig,
	unloadCB: cleanupGyro
});

// Initial load of snippet also loads threejs tools and invokes custom code
rtv.loadScripts(['https://threejs.org/build/three.min.js',
		'https://threejs.org/examples/js/controls/OrbitControls.js'],
            function () {
                makeGyro();                 // create the 3D object
                applyVarsToGyro(rtvPanel);  // apply initial var values
                addVarListeners();          // listen for future var changes
});
 
</script>
